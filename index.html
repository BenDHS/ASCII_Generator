<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  </html>
        <div>
          <label>Font size</label>
          <input type="number" id="font_size" value="12" min="6" max="48" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Black threshold</label>
          <input type="number" id="black_threshold" value="15" min="0" max="255" />
        </div>
        <div>
          <label>Char aspect (H/W)</label>
          <input type="number" id="char_aspect" value="0.55" min="0.3" max="1.2" step="0.01" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>FG color</label>
          <input type="text" id="fg_color" value="black" />
        </div>
        <div>
          <label>BG color</label>
          <input type="text" id="bg_color" value="white" />
        </div>
      </div>
      <div>
        <label>ASCII chars (darkâ†’light)</label>
        <input type="text" id="ascii_chars" value="@%#*+=-:. " />
      </div>
      <div class="row">
        <label class="row" style="gap:6px;">
          <input type="checkbox" id="invert" /> Invert luminance
        </label>
      </div>
      <div class="actions">
  <button id="refresh">Refresh Preview</button>
  <button id="fit">Fit To Box</button>
        <button id="downloadTxt">Download .txt</button>
        <button id="downloadPng">Download .png</button>
      </div>
    </div>
    <div class="panel">
      <div id="preview"><span class="small">No image yet. Upload to see preview.</span></div>
    </div>
  </div>

  <script src="/static/ascii.js"></script>
  <script>
    let currentImage = null; // HTMLImageElement
    let refreshTimer = null;
    const debounce = (fn, ms = 150) => (...args) => {
      clearTimeout(refreshTimer);
      refreshTimer = setTimeout(() => fn(...args), ms);
    };

    function gatherSettings() {
      return {
        output_width: Number(document.getElementById('output_width').value),
        ascii_chars: document.getElementById('ascii_chars').value || '@%#*+=-:. ',
        black_threshold: Number(document.getElementById('black_threshold').value),
        invert: document.getElementById('invert').checked,
        char_aspect: Number(document.getElementById('char_aspect').value),
        font_size: Number(document.getElementById('font_size').value),
        fg_color: document.getElementById('fg_color').value || 'black',
        bg_color: document.getElementById('bg_color').value || 'white',
      };
    }

    async function refreshPreview() {
      const previewHost = document.getElementById('preview');
      if (!currentImage) {
        previewHost.innerHTML = '<span class="small">No image yet. Upload to see preview.</span>';
        return;
      }
      const settings = gatherSettings();
      const ascii = await toAscii(currentImage, settings);
      const canvas = asciiToCanvas(ascii, settings);
      // apply target preview size
      const targetW = Number(document.getElementById('preview_w').value);
      const targetH = Number(document.getElementById('preview_h').value);
      previewHost.style.width = `${targetW}px`;
      previewHost.style.height = `${targetH}px`;
      previewHost.innerHTML = '';
      canvas.style.maxWidth = '100%';
      canvas.style.maxHeight = '100%';
      previewHost.appendChild(canvas);
    }

    function handleFile(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        URL.revokeObjectURL(url);
        currentImage = img;
        refreshPreview();
      };
      img.src = url;
    }

    // Wire up UI
    const fileInput = document.getElementById('file');
    fileInput.addEventListener('change', () => {
      if (fileInput.files && fileInput.files[0]) handleFile(fileInput.files[0]);
    });
    document.getElementById('refresh').addEventListener('click', refreshPreview);
    document.getElementById('fit').addEventListener('click', () => {
      if (!currentImage) return;
      // Compute recommended settings to roughly fit the box
      const boxW = Number(document.getElementById('preview_w').value);
      const boxH = Number(document.getElementById('preview_h').value);
      const fontSize = Number(document.getElementById('font_size').value);
      const charAspect = Number(document.getElementById('char_aspect').value);

      // Estimate character size in pixels using a monospace assumption
      // Width ~ 0.6 * fontSize, Height ~ 1.2 * fontSize
      const charW = Math.max(1, Math.round(0.6 * fontSize));
      const charH = Math.max(1, Math.round(1.2 * fontSize));

      // Given char aspect in algorithm is H/W scale factor; for the ASCII buffer height:
      // outH = outW * (imgH/imgW) * charAspect
      const iw = currentImage.naturalWidth;
      const ih = currentImage.naturalHeight;
      const imgAR = ih / iw;

      // We want the rendered canvas size (chars * char pixel size) to fit within boxW x boxH.
      // canvasW_px = outW * charW
      // canvasH_px = outH * charH = outW * imgAR * charAspect * charH
      // Fit both constraints; choose the tighter one
      const maxOutW_byWidth = Math.floor(boxW / charW);
      const maxOutW_byHeight = Math.floor(boxH / (imgAR * charAspect * charH));
      const outW = Math.max(20, Math.min(maxOutW_byWidth, maxOutW_byHeight));

      document.getElementById('output_width').value = outW;
      debounce(refreshPreview, 0)();
    });

    // Drag & drop onto preview panel
    const previewHost = document.getElementById('preview');
    previewHost.addEventListener('dragover', (e) => { e.preventDefault(); previewHost.style.background = '#fafafa'; });
    previewHost.addEventListener('dragleave', () => { previewHost.style.background = ''; });
    previewHost.addEventListener('drop', (e) => {
      e.preventDefault();
      previewHost.style.background = '';
      const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) handleFile(f);
    });

    // Auto-refresh on settings change (debounced)
    [
      'output_width','black_threshold','char_aspect','font_size',
      'ascii_chars','fg_color','bg_color','invert'
    ].forEach(id => {
      const el = document.getElementById(id);
      const evt = (el && el.type === 'checkbox') ? 'change' : 'input';
      el && el.addEventListener(evt, debounce(refreshPreview, 150));
    });

    // Refresh when preview box size changes
    ['preview_w','preview_h'].forEach(id => {
      const el = document.getElementById(id);
      el && el.addEventListener('input', debounce(refreshPreview, 150));
    });

    document.getElementById('downloadTxt').addEventListener('click', async () => {
      if (!currentImage) return;
      const ascii = await toAscii(currentImage, gatherSettings());
      const blob = new Blob([ascii], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ascii_art.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    document.getElementById('downloadPng').addEventListener('click', async () => {
      if (!currentImage) return;
      const ascii = await toAscii(currentImage, gatherSettings());
      const canvas = asciiToCanvas(ascii, gatherSettings());
      canvas.toBlob((blob) => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ascii_art.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });
    });
  </script>
</body>
</html>
